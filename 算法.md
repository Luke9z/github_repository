# 算法

## KMP

- 模式串和目标串: String str, String model

- 主要要构建最大公共前后缀，这样子匹配的时候，如果发现不同，直接从前一个字符的最大前缀位置开始继续匹配，不需要从头匹配

- ```java
  //构建最大前后公共缀
  public int[] getNext(String model){
      int j = 0;
      int[] next = new int[model.length];
      for(int i = 1; i < model.length(); i++){
          //如果发现不同
          while(j > 0 && model.charAt[i] != model.charAt[j]){
              //从前一个位置的最长前缀开始匹配，因为最长前后缀的长度，所以next[j-1]就是前一个最长前缀后一个位置
              j = next[j];
          }        
          //如果在遍历模式串的时候，前后缀相同，那么j++,表示最长前后缀长度加1
          if(model.charAt[i] == model.charAt[j]){
              j++;
          }
          //给next[i]赋值j，表示这个i位置的最长前后缀为j
          next[i] = j;
      }
  }
  ```

- 构建next数组以后，就可以使用next数组与我们需要匹配的字符串进行匹配了，其原理和我们构建next数组基本相同，在我们进行匹配时，如果发现不同的话，从前一个位置的最长前缀的下一个位置开始匹配。

- ```java
  //返回boolean，是否有这个字符
  public boolean hasThisString(String target, String model){
      int[] next = getNext(model);
      int j = 0;
      
      for(int i = 0; i < target.length(); i++){
          //如果不同，我们需要从不同位置的前一个位置的最长前缀开始，继续匹配
          while(j > 0 && target.charAt(i) != model.charAt(j)){
              j = next[j-1];
          }
          //如果相同，j++
          if(target.charAt(i) == model.charAt(j)){
              //继续匹配下一个
              j++;
          }
          if(j == model.length()){
              //说明全部匹配完成
              return true;
          }
      }
      //说明没有匹配成功
      return false;
  }
  ```

## 回溯

### 基础回溯 LeetCode77

- 回溯其实就是树结构，每一层递归中进行for循环

  - ```java
    class Solution {
        List<Integer> combination = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        public List<List<Integer>> combine(int n, int k) {
            countCombine(1, n, k);
            return result;
        }
    
        public void countCombine(int start, int n, int k){
            if (k == 0) {
                result.add(new ArrayList<>(combination));
                return;
            }
            for (int i = start; i <= n + 1 - k; i++) {
                combination.add(i);
                countCombine(i + 1, n, k - 1);
                combination.remove(combination.size() - 1);
            }
        }
    }
    ```


### 回溯去重 LeetCode 40

- 这一题需要将得到的答案去重：

  - Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

    Each number in `candidates` may only be used **once** in the combination.

    **Note:** The solution set must not contain duplicate combinations.

    **Example 1:**

    ```
    Input: candidates = [10,1,2,7,6,1,5], target = 8
    Output: 
    [
    [1,1,6],
    [1,2,5],
    [1,7],
    [2,6]
    ]
    ```

    **Example 2:**

    ```
    Input: candidates = [2,5,2,1,2], target = 5
    Output: 
    [
    [1,2,2],
    [5]
    ]
    ```

- 排序以后，正常使用回溯的话，会有重复的答案，所以我们要在回溯的过程中将重复答案去重，这一步如何达到呢？

  - 注意：以下去重方式只能使用与可以排列的数组，因为排列以后，两个相同的数字会放在一起，这样子才可以用一个used数组来维护，如果数组不允许排列， 那么只能使用set来进行去重

  - 我们可以发现，在同一个组合中，可以出现重复的元素，这是没有问题的，但是不同的组合中，我们不能出现相同的两个组合。

  - 这就需要在for循环的过程中，如果发现前一个元素和当前下标相同，且前一个元素没有在使用中，需要continue跳过了，因为如果前一个元素在选择中的话，说明我们现在在同一个组合中，如果前一个元素没有在选中过程中，说明我们现在在不同的组合，就需要跳过当前元素。

  - 使用一个`int[] used`数组来进行维护，`for循环`主体如下:

  - ```java
    for (int i = startIndex; i < candidates.length && temp + candidates[i] <= target; i++) {
        if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] != 1) {
        	continue;
        }
        temp += candidates[i];
        path.add(candidates[i]);
        used[i] = 1;
        findCombination(i + 1, candidates, target);
        temp -= candidates[i];
        path.remove(path.size() - 1);
        used[i] = 0;
    }
    ```

### 回溯子集问题 LeetCode 78

- 这一题是想找到一个数组的所有子集

  - Given an integer array `nums` of **unique** elements, return *all possible subsets (the power set)*.

    The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

    **Example 1:**

    ```
    Input: nums = [1,2,3]
    Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
    ```

    **Example 2:**

    ```
    Input: nums = [0]
    Output: [[],[0]]
    ```

- 其实这个数组的所有子集，就是我们在回溯过程中，所有的节点。如果回溯作为一个树的话，组合问题就是找到这个树的叶子节点，而子集问题就是找到这个树的所有节点，所以在我们回溯的过程中，将每一个path都收集，就可以获得所有子集了

  - ```java
    public void findSubsets(int startIndex, int[] nums) {
        for (int i = startIndex; i < nums.length; i++) {
            path.add(nums[i]);
            result.add(new ArrayList<>(path));
            findSubsets(i + 1, nums);
            path.remove(path.size() - 1);
        }
    }
    ```

### 回溯子集去重 LeetCode 90

- 其实就是回溯去重与回溯子集相结合，一样建立一个`int[] used`表去进行维护，如果前一个元素正在使用，说明同组，可以重复；前一个元素不在使用，说明不同组，不可以重复使用。

- ```java
  public void findSubsets(int startIndex, int[] nums) {
      for (int i = startIndex; i < nums.length; i++) {
          if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == 0) {
              continue;
          }
              path.add(nums[i]);
              used[i] = 1;
              result.add(new ArrayList<>(path));
              findSubsets(i + 1, nums);
              path.remove(path.size() - 1);
              used[i] = 0;
          }
  }
  ```

### 回溯子集去重，不允许排序 LeetCode 491

- 这道题是不允许对原数组进行排序的，但是去重的原理还是一样的，就是如果单层for循环中使用过了一个元素，这个元素后续就不可以再次使用了，我们利用Set来进行去重

  - Given an integer array `nums`, return *all the different possible non-decreasing subsequences of the given array with at least two elements*. You may return the answer in **any order**.

    **Example 1:**

    ```
    Input: nums = [4,6,7,7]
    Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
    ```

    **Example 2:**

    ```
    Input: nums = [4,4,3,2,1]
    Output: [[4,4]]
    ```

- 主要代码如下：

  - ```java
    public void findAllSubsequences(int startIndex, int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i = startIndex; i < nums.length; i++) {
            //在放入path之前，如果放入的元素比path里面的元素小的话，就跳过这次
            if (!path.isEmpty() && nums[i] < path.get(path.size() - 1)) {
            	continue;
            }
            //如果本层使用过这个元素，那么就跳过
            if (set.contains(nums[i])) {
            	continue;
            }
            path.add(nums[i]);
            set.add(nums[i]);
            if (path.size() >= 2) {
                result.add(new ArrayList<>(path));
            }
            findAllSubsequences(i + 1, nums);
            path.remove(path.size() - 1);
        }
    }
    ```

### 回溯，不需要startIndex，全排列问题，LeetCode 46

- 这道题的话，就不需要使用startIndex来更新每一层的开始下标，因为他要求所有排列的情况，但是我们需要一个`boolean[] used`数组来维护哪些元素我们已经使用过了，这样子就不会重复选择。

  - Given an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.

    **Example 1:**

    ```
    Input: nums = [1,2,3]
    Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    ```

    **Example 2:**

    ```
    Input: nums = [0,1]
    Output: [[0,1],[1,0]]
    ```

    **Example 3:**

    ```
    Input: nums = [1]
    Output: [[1]]
    ```

- 核心代码如下：

  - ```java
    public void findPermutations(int startIndex, int[] nums) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(used[i]){
            	continue;
        	}
            path.add(nums[i]);
            used[i] = true;
            findPermutations(startIndex + 1, nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
    ```

### 超级之回溯机票，LeetCode332

- 题目本身不难，但是如果不超时过还是需要用合适的数据结构

  - You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.

    All of the tickets belong to a man who departs from `"JFK"`, thus, the itinerary must begin with `"JFK"`. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

    - For example, the itinerary `["JFK", "LGA"]` has a smaller lexical order than `["JFK", "LGB"]`.

    You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

    **Example 1:**

    ![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

    ```
    Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
    Output: ["JFK","MUC","LHR","SFO","SJC"]
    ```

    **Example 2:**

    ![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)

    ```
    Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
    Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
    Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.
    ```

- 其实也是使用回溯，从JFK开始，对下一个机场进行回溯遍历，找出结果。需要注意的是：

  - 使用`Map<String, Map<String, Integer>>`这样的结构来存储`tickets`。可以快速的找到下一个需要去的机场的位置。
  - `Map<String, Map<String, Integer>>`中的`Map<String, Integer>`我们使用TreeMap来存储，通过存储机场的名字来排序，因为答案需要最小的`lexical order`所以我们每一次都选择尽量小的机场来寻找答案，这样子就不需要遍历完所有的机场
  - 在这道题中的回溯返回值应该是`boolean`，因为我们在找到一条路径的时候，实际上也已经找到了最终答案，所以我们希望直接返回这个答案，如果返回值依旧是`void`的话，就不好进行递归的结束，如果返回是`boolean`，那么在进行下层递归的时候，`if`判断返回值，如果返回`true`，那么继续向上返回，这样子就可以直接从底层结束递归。

- 来看代码：

  - ```java
    class Solution {
        List<String> path; //存储路径
        Map<String, Map<String, Integer>> map; //存储机票信息，第二个map存储相同机场的数目
    
        int ticketNumber = 0;
        public List<String> findItinerary(List<List<String>> tickets) {
            map = new HashMap<>();
            path = new ArrayList<>();
            result = new ArrayList<>();
            ticketNumber = tickets.size();
            for (List<String> ticket : tickets) {
                //初始化TreeMap,有序的存储一个城市的后续城市
                Map<String, Integer> temp = map.getOrDefault(ticket.get(0), new TreeMap<>());
                temp.put(ticket.get(1), temp.getOrDefault(ticket.get(1), 0) + 1);
                map.put(ticket.get(0), temp);
            }
            //以"JFK"机场开始搜寻
            path.add("JFK");
            find("JFK");
            return path;
        }
    
        public boolean find(String departure){
            //如果我们的路径是机票数量+1，那么说明已经找到了一条使用过所有机票的路径
            if (path.size() == ticketNumber + 1) {
                return true;
            }
            Map<String, Integer> nextDepartures = map.get(departure);
            if (nextDepartures != null) {
                for (Map.Entry<String, Integer> target : nextDepartures.entrySet()) {
                    //这个count是后续机场的数量，如果count为0的话，说明这个后续机场已经飞过了，不可以再次飞行
                    int count = target.getValue();
                    if (count > 0) {
                        //如果不为0，在path中添加后续机场，然后将后续机场的数量-1
                        path.add(target.getKey());
                        target.setValue(count - 1);
                        //进行递归搜寻，如果返回true，继续向上返回
                        if(find(target.getKey())){
                            return true;
                        };
                        //将机场数量还原
                        target.setValue(count);
                        //将机场从path中移除
                        path.remove(path.size() - 1);
                    }
                }
            }
            return false;
        }
    }
    ```


### 超级回溯之N皇后

- N皇后其实并不难，只要理解了回溯的本质，其实就是每放一个格子，去下行开始放，同时检查每一个位置是否可以放置。

  - The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

    Given an integer `n`, return *all distinct solutions to the **n-queens puzzle***. You may return the answer in **any order**.

    Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.

    **Example 1:**

    ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

    ```
    Input: n = 4
    Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
    Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
    ```

    **Example 2:**

    ```
    Input: n = 1
    Output: [["Q"]]
    ```

- 核心代码如下，这里我是用`int[][] chessboard`，其实直接使用`char[][] chessboard`来存储答案就可以了

  - ```java
    	public void findSolution(int[][] chessboard, int startRow) {
            if(startRow == chessboard.length){
                for (int[] chess : chessboard) {
                    StringBuilder sb = new StringBuilder();
                    for (int num : chess) {
                        if (num == 0) {
                            sb.append(".");
                        }else{
                            sb.append("Q");
                        }
                    }
                    path.add(sb.toString());
                }
                result.add(new ArrayList<>(path));
                path = new ArrayList<>();
                return;
            }
            for (int j = 0; j < chessboard.length; j++) {
                if (positionValid(chessboard, startRow, j)) {
                    chessboard[startRow][j] = 1;
                    findSolution(chessboard, startRow + 1);
                    chessboard[startRow][j] = 0;
                }
            }
        }
    ```

- 个人感觉是比机票问题简单的，因为机票问题使用的数据结构需要好好考量，这道题其实比较的straitforward

### 超级回溯之解数独

- 这道题其实也不算难，唯一难点就是，整个回溯过程不需要终止条件，因为如果数独没有解的话，那么在我们遍历其中一个格子的时候，会发现每一个数字都不能往下递归到最后，那么在我们尝试完所有数字的时候没有找到解，直接`return false`就好。

  - Write a program to solve a Sudoku puzzle by filling the empty cells.

    A sudoku solution must satisfy **all of the following rules**:

    1. Each of the digits `1-9` must occur exactly once in each row.
    2. Each of the digits `1-9` must occur exactly once in each column.
    3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.

    The `'.'` character indicates empty cells.

    

    **Example 1:**

    ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

    ```
    Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
    Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
    Explanation: The input board is shown above and the only valid solution is shown below:
    ```

- 同样，这里的回溯代码`return boolean`，因为找到唯一解就可以返回了

  - ```java
    	public boolean soleSudokuHelper(char[][] board){
            for (int i = 0; i < board.length; i++) {
                for (int j = 0; j < board.length; j++) {
                    if (board[i][j] == '.') {
                        for (char z = '1'; z <= '9'; z++) {
                            if (isRepeated(board, i, j, z)) {
                                board[i][j] = z;
                                if (soleSudokuHelper(board)) {
                                    return true;
                                }
                                board[i][j] = '.';
                            }
                        }
                        //这段代码如果可以执行，说明有一层往下递归的时候，永远会返回到这一层，那么说明这个数独无解，直接向上返回false
                        return false;
                    }
                }
            }
            return true;
        }
    ```

## 贪心

### 分发饼干，LeetCode 455(没做出来)

- 这一题是很好的入门题目，主要就是将大饼干优先给大胃口的孩子吃，这样局部优先就可以推导到全局优先

  - Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

    Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.

    **Example 1:**

    ```
    Input: g = [1,2,3], s = [1,1]
    Output: 1
    Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
    And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
    You need to output 1.
    ```

    **Example 2:**

    ```
    Input: g = [1,2], s = [1,2,3]
    Output: 2
    Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
    You have 3 cookies and their sizes are big enough to gratify all of the children, 
    You need to output 2.
    ```

- 代码很简单，如下：

  - ```java
    class Solution {
        public int findContentChildren(int[] g, int[] s) {
            Arrays.sort(g);
            Arrays.sort(s);
            int result = 0;
            int cookieIndex = s.length - 1;
            int greedyIndex = g.length - 1;
            if (s.length == 0) {
                return 0;
            }
            //满足大胃口
            while (cookieIndex >= 0 && greedyIndex >= 0) {
                if (s[cookieIndex] >= g[greedyIndex]) {
                    cookieIndex--;
                    greedyIndex--;
                    result++;
                }else{
                    greedyIndex--;
                }
            }
            return result;
        }
    }
    ```

### 摆动序列 LeetCode 376(没做出来)

- 这道题我们要分清楚三个情况来统计最长的摆动序列。

  - 上下坡中有平坡

    - `(preDiff >= 0 && curDiff < 0) || (preDiff <= 0 && curDiff > 0)`，这样子就可以删除平坡中的重复数据了

  - 数组首位两端

    - 可以假设首前端还有一个数字，和首位相同，这样子在统计第一个和第二个数字的时候`preDiff == 0`，`curDiff`大于或者小于0都会被统计上，然后默认有一个峰值，`result = 1`。

  - 单调坡中有平坡

    - 如果我们每次都更新`preDiff`的话，那么在一个单调上升(或下降)区间中的平坡到再次上升(或下降)时，就会多统计坡度变化的节点，但是其实只需要统计单调上坡最后一个就好了，那么我们就不需要每次都更新`preDiff`，而是在判断有摆动的时候再更新。

  - A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.

    - For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.
    - In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.

    A **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.

    Given an integer array `nums`, return *the length of the longest **wiggle subsequence** of* `nums`.

    **Example 1:**

    ```
    Input: nums = [1,7,4,9,2,5]
    Output: 6
    Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
    ```

    **Example 2:**

    ```
    Input: nums = [1,17,5,10,13,15,10,5,16,8]
    Output: 7
    Explanation: There are several subsequences that achieve this length.
    One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).
    ```

    **Example 3:**

    ```
    Input: nums = [1,2,3,4,5,6,7,8,9]
    Output: 2
    ```

- 代码如下：

  - ```java
    class Solution {
        public int wiggleMaxLength(int[] nums) {
            if (nums.length <= 1) {
                return nums.length;
            }
            int preDiff = 0;
            int curDiff = 0;
            int count = 1;
            for (int i = 0; i < nums.length - 1; i++) {
                curDiff = nums[i + 1] - nums[i];
                if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                    count++;
                    preDiff = curDiff;
                }
            }
            return count;
        }
    }
    ```

### 最大子序和 LeetCode 53

- 局部最优：`result`是遍历过的子序列中的最大值

  - Given an integer array `nums`, find the subarray with the largest sum, and return *its sum*.

    **Example 1:**

    ```
    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
    Output: 6
    Explanation: The subarray [4,-1,2,1] has the largest sum 6.
    ```

    **Example 2:**

    ```
    Input: nums = [1]
    Output: 1
    Explanation: The subarray [1] has the largest sum 1.
    ```

    **Example 3:**

    ```
    Input: nums = [5,4,-1,7,8]
    Output: 23
    Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
    ```

- 其实很好理解，使用贪心的话，我们维护一个`sum`变量，用来记录子数组的和，如果在加入一个元素后发现：

  - 这个元素比我们的`sum`要大的话，就更新`sum`为这个元素。

  - 一个`result`变量一直记录`sum`的最大值。因为我们的`sum`肯定是一个子数组的和，所以我们只要记录这些子数组和中最大的一个，就是答案了。

  - ```java
    class Solution {
        public int maxSubArray(int[] nums) {
            //如果后面的数字超过了前面的总和，那么更新sum
            int sum = nums[0];
            int result = sum;
            for (int i = 1; i < nums.length; i++) {
                sum += nums[i];
                if (nums[i] > sum) {
                    sum = nums[i];
                }
                result = Math.max(sum, result);
            }
            return result;
        }
    }
    ```

### 买卖股票最佳时机II LeetCode 122

- You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

  On each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.

  Find and return *the **maximum** profit you can achieve*.

  **Example 1:**

  ```
  Input: prices = [7,1,5,3,6,4]
  Output: 7
  Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
  Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
  Total profit is 4 + 3 = 7.
  ```

  **Example 2:**

  ```
  Input: prices = [1,2,3,4,5]
  Output: 4
  Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
  Total profit is 4.
  ```

  **Example 3:**

  ```
  Input: prices = [7,6,4,3,1]
  Output: 0
  Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
  ```

- 这道题我自己的思路是：	

  - 每一天都要买股票！
  - 如果第二天的股票价格比今天高，那么第二卖出
  - 如果第二天的股票价格比今天低，那么今天卖出

- 这样子就可以收集每两天之间的正收益，累加起来就是结果了

- 其实随想录中的，直接将收益转换成一个数组，然后把所有正数都加上，是一个思路。

- 上代码：

  - ```java
    class Solution {
        public int maxProfit(int[] prices) {
            //每天都买股票，如果第二天比现在的股票贵，那么第二天卖掉
            //              如果第二天比现在的股票便宜或者相等，那么今天卖掉
            int transaction = 0;
            for (int i = 0; i < prices.length - 1; i++) {
                transaction -= prices[i]; //每天都买股票
                transaction += Math.max(prices[i + 1], prices[i]);
            }
            return transaction;
        }
    }
    ```

### 跳跃游戏 LeetCode 55

- 这道题我自己是没用到贪心的，思维不够敏捷，讲讲我的思路吧：

  - 因为只要没有遇到0，那么就肯定是可以到达最后的`index`。

  - 如果遍历数组的时候遇到了0，那么就往前遍历，看看是否有一个数字可以跳过这个0区域，如果一直到数组开头都没有的话，那么说明这个0过不去，`return false`就好了

  - You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.

    Return `true` *if you can reach the last index, or* `false` *otherwise*.

    **Example 1:**

    ```
    Input: nums = [2,3,1,1,4]
    Output: true
    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
    ```

    **Example 2:**

    ```
    Input: nums = [3,2,1,0,4]
    Output: false
    Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
    ```

- 我的代码：

  - ```java
    class Solution {
        public boolean canJump(int[] nums) {
            if (nums.length == 1 & nums[0] == 0) {
                return true;
            } else if (nums[0] == 0) {
                return false;
            }
            //遍历数组，如果遇到nums[i] == 0的情况，往前寻找是否可以跳过这个0
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] == 0) {
                    //如果此时 i 为 nums.length - 1,也就是最后一个index，那么返回true就可以了，因为已经到最后了
                    if(i == nums.length - 1 ){
                        return true;
                    }
                    int j = i - 1;
                    while ((i - j) >= nums[j]) {
                        j--;
                        if (j < 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
    }
    ```

  - 但其实，使用贪心的话，会更好理解：

    - 不用去纠结怎么选择跳法，我们只要维护一个`int cover`来表示现在可以跳到的最远区域是哪里，如果这个区域可以盖过`last index`，那么返回true

    - ```java
      class Solution {
          public boolean canJump(int[] nums) {
              int cover = 0;
              //要注意，因为我们最终只能达到 -cover这个下标。
              for(int i = 0; i <= cover; i++){
                  cover = Math.max(nums[i] + i, cover);
                  if(cover >= nums.length - 1){
                      return true;
                  }
              }
              return false;
          }
      }
      ```

### 跳跃游戏II LeetCode 45(没做出来)

- 和跳跃游戏的思路有共同点，都是根据最大的覆盖范围来寻找

  - You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.

    Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:

    - `0 <= j <= nums[i]` and
    - `i + j < n`

    Return *the minimum number of jumps to reach* `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.

    **Example 1:**

    ```
    Input: nums = [2,3,1,1,4]
    Output: 2
    Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
    ```

    **Example 2:**

    ```
    Input: nums = [2,3,0,1,4]
    Output: 2
    ```

- 这道题要注意的是，步数统计的问题：

  - 当我们移动指针的时候，如果到达现在的覆盖范围，但是其中没有找到最大的覆盖范围到达终点，那么我们就得将现在的覆盖范围更新到最大的覆盖范围，继续寻找。

  - 因为在现在的覆盖范围内，我们一步就可以跳到，但是更新到现在覆盖范围中的最大覆盖范围时，要多跳一步，那么在最大的覆盖范围中的步数便是2步可以跳到，以此类推

  - ```java
    class Solution {
        public int jump(int[] nums) {
            if (nums.length == 1) {
                return 0;
            }
            int maxCover = 0;
            int result = 0;
            int curCover = 0;
            for (int i = 0; i < nums.length; i++) {
                maxCover = Math.max(maxCover, nums[i] + i);
                //如果最大覆盖范围可以到达终点，那么从当前直接跳到这个最大覆盖范围的起始下标跳一步，到终点就是第二步
                if (maxCover >= nums.length - 1) {
                    result++;
                    return result;
                }
                //说明当前覆盖区域内，没有找到一个最大的覆盖区域可以到达终点
                //那么更新当前覆盖区域到最大的覆盖区域，继续寻找
                if (i == curCover) {
                    curCover = maxCover;
                    result++;
                }
            }
            return result;
        }
    }
    ```

### K次取反后最大化的数组和 LeetCode 1005

- 这道题思路是非常简单的，但是我写的边界条件有些多，也不妨记录一下：

  - Given an integer array `nums` and an integer `k`, modify the array in the following way:

    - choose an index `i` and replace `nums[i]` with `-nums[i]`.

    You should apply this process exactly `k` times. You may choose the same index `i` multiple times.

    Return *the largest possible sum of the array after modifying it in this way*.

    **Example 1:**

    ```
    Input: nums = [4,2,3], k = 1
    Output: 5
    Explanation: Choose index 1 and nums becomes [4,-2,3].
    ```

    **Example 2:**

    ```
    Input: nums = [3,-1,0,2], k = 3
    Output: 6
    Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].
    ```

    **Example 3:**

    ```
    Input: nums = [2,-3,-1,5,-4], k = 2
    Output: 13
    Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].
    ```

  - 如果负数的数量大于k的话，那么将负数反转完以后，从最后一个负数反转后的正数与原来的第一个正数(或者0)比较，哪个小就将剩下的k用到他身上

  - 如果负数的数量小于k的话，那么直接反转所有负数即可。

- 代码：

  - ```java
    class Solution {
        public int largestSumAfterKNegations(int[] nums, int k) {
            Arrays.sort(nums);
            //如果负数数量大过k，直接按顺序将最小的负数取反
            //如果负数数量小于k，将负数取反后，选择最小的正数(或者0)，消耗完剩余的k
            int count = 0;
            int index = 0;
            while (count < k) {
                if (nums[index] < 0) {
                    nums[index] = -nums[index];
                    count++;
                }else{
                    if (index == 0 || nums[index - 1] > nums[index]) {
                        nums[index] = (k - count) % 2 == 1 ? -nums[index] : nums[index];
                    }else{
                        nums[index - 1] = (k - count) % 2 == 1 ? -nums[index - 1] : nums[index - 1];
                    }
                    break;
                }
                index++;
                //这里是防止所有数字都是负数且 k > nums.length，那么将下标更新到最后一位
                //此时因为所有都反转了，可以直接进行选择最小正数。
                if (index == nums.length) {
                    index = nums.length - 1;
                }
            }
            return Arrays.stream(nums).sum();
        }
    }
    ```

- 随想录的解法是：

  - 按照绝对值排序，然后选择所有负数反转成正数，如果k还有，则选择最小正数进行反转操作。其实思路是一样的。

### 加油站 LeetCode 134(没做出来)

- 这道题从逻辑上入手，使用贪心

  - There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.

    You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.

    Given two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**

    **Example 1:**

    ```
    Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
    Output: 3
    Explanation:
    Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
    Travel to station 4. Your tank = 4 - 1 + 5 = 8
    Travel to station 0. Your tank = 8 - 2 + 1 = 7
    Travel to station 1. Your tank = 7 - 3 + 2 = 6
    Travel to station 2. Your tank = 6 - 4 + 3 = 5
    Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
    Therefore, return 3 as the starting index.
    ```

    **Example 2:**

    ```
    Input: gas = [2,3,4], cost = [3,4,3]
    Output: -1
    Explanation:
    You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
    Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
    Travel to station 0. Your tank = 4 - 3 + 2 = 3
    Travel to station 1. Your tank = 3 - 3 + 3 = 3
    You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
    Therefore, you can't travel around the circuit once no matter where you start.
    ```

  - 可以从`index = 0 `开始遍历，将`gas[i] - cost[i]`的和记录下来，如果发现为负数的话，那么就要将起始位置更新为`i + 1`

  - 如果可以完成一圈的话，`gas[i] - cost[i]`的累加和为负说明起始点肯定不在`0 ~ i`之间，那么我们就更新位置到`i + 1`且将累加和重置为0。继续尝试，直到遍历完整个数组。

  - 遍历的过程中我们也要使用一个`totalSum`来记录整个数组`gas[i] - cost[i]`的和，如果这个和为负数的话，说明没有一个起点可以完成绕一圈。

- 代码：

  - ```java
    class Solution {
        public int canCompleteCircuit(int[] gas, int[] cost) {
            int curSum = 0;
            int totalSum = 0;
            int start = 0;
            for (int i = 0; i < gas.length; i++) {
                curSum += gas[i] - cost[i];
                totalSum += gas[i] - cost[i];
                if (curSum < 0) {
                    start = i + 1;
                    curSum = 0;
                }
            }
            if (totalSum < 0) {
                return -1;
            }
            return start;
        }
    }
    ```

### 分发糖果 LeetCode 135(没做出来)

- 我的主要原因是同时顾虑左右两个孩子评分，就会很混乱。

  - There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.

    You are giving candies to these children subjected to the following requirements:

    - Each child must have at least one candy.
    - Children with a higher rating get more candies than their neighbors.

    Return *the minimum number of candies you need to have to distribute the candies to the children*.

    **Example 1:**

    ```
    Input: ratings = [1,0,2]
    Output: 5
    Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.
    ```

    **Example 2:**

    ```
    Input: ratings = [1,2,2]
    Output: 4
    Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
    The third child gets 1 candy because it satisfies the above two conditions.
    ```

- 正确步骤

  - 首先先确认好右孩子评分比左孩子评分大的情况，给评分大的孩子多加一个糖果，保证右边评分高的孩子有更多的糖果
  - 然后再确认左孩子评分比右孩子评分大的情况，这里数组遍历的时候应该从后往前，因为在确认左孩子大的时候，我们更新的是左孩子，所以得用到上一个左孩子的数据，也就是得从后往前，如果从前往后，就用不到上一个左孩子的数据。
  - 在确认左孩子评分比右孩子评分大时，更新左孩子数据不是简单的`candies[i] = candies[i + 1] + 1`，因为我们还得同时满足右孩子大的情况，所以`candies[i]`中本身已经有数据了，这个时候如果更新的`candids[i + 1] + 1 < candies[i]`，那么我们第一次比较右孩子的情况就被覆盖了，不能满足了，所以我们要选择更大的一个作为更新的值，也就是`Math.max(candies[i], candies[i + 1] + 1);`

- 代码如下：

  - ```java
    class Solution {
        public int candy(int[] ratings) {
            //先确定右边评分大于左边 从前往后遍历
            int[] candies = new int[ratings.length];
            for (int i = 1; i < ratings.length; i++) {
                if (ratings[i] > ratings[i - 1]) {
                    candies[i] = candies[i - 1] + 1;
                }
            }
            //从后往前遍历，确认左边评分比右边大
            for (int i = ratings.length - 2; i >= 0; i--) {
                if (ratings[i] > ratings[i + 1]) {
                    candies[i] = Math.max(candies[i + 1] + 1, candies[i]);
                }
            }
    
            return Arrays.stream(candies).sum() + ratings.length;
        }
    
    }
    ```

### 根据身高重建队列 LeetCode 406(没做出来)

- 这道题和分发糖果有些像，都是有两个维度，这种两个维度的情况下，必须得分开来考虑，要不然会顾及不来

  - You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`.

    Reconstruct and return *the queue that is represented by the input array* `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).

    **Example 1:**

    ```
    Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
    Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
    Explanation:
    Person 0 has height 5 with no other people taller or the same height in front.
    Person 1 has height 7 with no other people taller or the same height in front.
    Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
    Person 3 has height 6 with one person taller or the same height in front, which is person 1.
    Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
    Person 5 has height 7 with one person taller or the same height in front, which is person 1.
    Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
    ```

    **Example 2:**

    ```
    Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
    Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
    ```

- 思路是什么呢？

  - 根据身高降序来排序原数组，高的人站前面，矮的人站后面，如果相同，那么`k`小的人站在前面
  - 这样子在我们重构遍历的时候，因为前面的人肯定是高的，所以后面的人可以放心的直接插入到新数组对应的`k`中。

- 代码：

  - ```java
    class Solution {
        public int[][] reconstructQueue(int[][] people) {
            // 身高从大到小排（身高相同k小的站前面）
            Arrays.sort(people, (a, b) -> {
                if (a[0] == b[0]) return a[1] - b[1];   // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列
                return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列
            });
            LinkedList<int[]> que = new LinkedList<>();
            for (int[] p : people) {
                que.add(p[1],p);   //Linkedlist.add(index, value)，會將value插入到指定index裡。
            }
            return que.toArray(new int[people.length][]);
        }
    }
    ```

- 

## 动态规划（老子要死磕）

### 斐波那契数列 LeetCode 509

- 牢记动态规划5部曲

  - 确认`dp[i]`数组和`i`下标的含义
    - `dp[i]` 为`i`的斐波那契数
  - 确认递归公式
    - `dp[i] = dp[i - 1] + dp[i - 2]`
  - 确认如何初始化
    - `dp[0] = 0; dp[1] = 1`
  - 确认遍历顺序
    - 从前往后遍历
  - 推导确认结果

- ```java
  class Solution {
      public int fib(int n) {
          if (n == 0) {
              return 0;
          }
          if (n == 1) {
              return 1;
          }
          //确认dp数组和dp下标含义
          //dp[i] 为： 第i个数的斐波那契值为dp[i]
          //递推公式： dp[i] = dp[i - 1] + dp[i - 2]
          // 如何初始化： dp[0] = 0, dp[1] = 1
          //遍历顺序： 从前往后
          //推到dp数组
          int[] dp = new int[n + 1];
          dp[0] = 0;
          dp[1] = 1;
  
          for (int i = 2; i <= n; i++) {
              dp[i] = dp[i - 1] + dp[i - 2];
          }
          return dp[n];
      }
  }
  ```

### 爬楼梯 LeetCode 70

- ```java
  class Solution {
  
      public int climbStairs(int n) {
          //确认dp数组含义
              //dp[i] 为 爬到 i 楼层有几步
          //确认递归公式
              //上 i - 1 楼梯的时候 有 dp[i - 1]，那么再跨一步就是 i
              //上 i - 2 楼梯的时候 有 dp[i - 2]，那么再跨两步就是 i
              //所以 dp[i] = dp[i - 1] + dp[i - 2];
          //初始化dp数组
              //dp[1] = 1, dp[2] = 2
          //遍历顺序
              //从前往后遍历
          if (n == 1) {
              return 1;
          }
          if (n == 2) {
              return 2;
          }
          int[] dp = new int[n + 1];
          dp[1] = 1;
          dp[2] = 2;
          for (int i = 3; i <= n; i++) {
              dp[i] = dp[i - 1] + dp[i - 2];
          }
          return dp[n];
      }
  
  }
  ```

### 使用最小cost爬楼梯(没做出来)

- 一定要记住，我们推导公式的时候，时刻使用前序状态来进行推导，不能空想来推导

  - ```java
    class Solution {
        public int minCostClimbingStairs(int[] cost) {
            //确认dp数组
                //dp[i] 为在 i 台阶上 最小的cost
            //确认递推公式
            	//如何到达 i 台阶呢，从 i - 1 花费 cost[i - 1] 或者 从 i - 2 花费 cost[i - 2]
                //因为是需要最小，所以我们选择这两个方案中最小的作为dp[i]
                //dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
            //初始化dp数组
                //dp[0] = 0, dp[1] = 0, dp[2] = Math.min(dp[1] + cost[1], dp[0] + cost[0]);
            //遍历顺序
                //从前往后
    
            int[] dp = new int[cost.length + 1];
            dp[0] = 0;
            dp[1] = 0;
            for (int i = 2; i < dp.length; i++) {
                dp[i] = Math.min(dp[i - 1] + cost[i - 1],
                        dp[i - 2] + cost[i - 2]);
            }
            return dp[dp.length - 1];
        }
    }
    ```

### 不同路径

- 题目：

  - There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.

    Given the two integers `m` and `n`, return *the number of possible unique paths that the robot can take to reach the bottom-right corner*.

    The test cases are generated so that the answer will be less than or equal to `2 * 109`.

    **Example 1:**

    ![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

    ```
    Input: m = 3, n = 7
    Output: 28
    ```

    **Example 2:**

    ```
    Input: m = 3, n = 2
    Output: 3
    Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
    1. Right -> Down -> Down
    2. Down -> Down -> Right
    3. Down -> Right -> Down
    ```

- 牢记五部曲

  - ```java
    class Solution {
        public int uniquePaths(int m, int n) {
            //确认dp数组：
                //dp[m][n] 是 机器人在 m n位置时有多少条路径可以到达
            //确认递推公式：
            	//上一个格子的路径和左一个格子的路径和
                //dp[m][n] = dp[m - 1][n] + dp[m][n - 1]
            //初始化dp数组：
                //dp[0][0 ~ n] = 1;
                //dp[0 ~ m][0] = 1;
            int[][] dp = new int[m][n];
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (i == 0) {
                        dp[i][j] = 1;
                    }else if (j == 0) {
                        dp[i][j] = 1;
                    }else {
                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    }
                }
            }
            
            return dp[m - 1][n - 1];
        }
    }
    ```

### 不同路径II

- 这道题我的初始化dp数组的时候，多给了一行和一列给dp数组，这样子就不会出现越界的情况，而且也不用提前给第一行和第一列初始化，只需要给`dp[0][0]`初始化为1就行了

- 代码：

  - ```java
    class Solution {
        public int uniquePathsWithObstacles(int[][] obstacleGrid) {
            //dp数组含义
                //dp[i][j] 代表机器人到达i j 有几种方式
            //递推公式
                // if(obstacleGrid[i][j] == 1) dp[i][j] = 0;
                // dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            //初始化
                //dp[0 ~ m][0] = 1
                //dp[0][0 ~ n] = 1
            //多给一行和一列
            int[][] dp = new int[obstacleGrid.length + 1][obstacleGrid[0].length + 1];
            dp[1][1] = 1;
            for (int i = 1; i < dp.length; i++) {
                for (int j = 1; j < dp[i].length; j++) {
                    if (obstacleGrid[i - 1][j - 1] == 1) {
                        dp[i][j] = 0;
                        continue;
                    }
                    if (i == 1 && j == 1) {
                        continue;
                    }
                    //多出的一行和一列都为0，就可以不去初始化原来的第一行和第一列，直接使用递推公式。
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    
                }
            }
            return dp[obstacleGrid.length][obstacleGrid[0].length];
        }
    
    }
    ```

### 整数拆分 LeetCode 343

- 要严格按照定义的dp数组

  - `dp[i]`为将`i`数字拆分后的最大乘积

  - 递推公式为:

    - ```java
      //从 1 ~ i中遍历，选取j, 一种乘积为 j*(i - j),另一种乘积是 j * dp[i - j], 从中选取最大值就是我们的dp[i]了
      for(int j = 1; j <= i - j; j++){
      	dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]))
      }
      ```

    - 这样子才符合我们的`dp`数组的含义。

  - 初始化就可以将`dp[2] = 1`

- 代码为：

  - ```java
    class Solution {
        public int integerBreak(int n) {
            //dp[i] 为正整数 i 拆分后的结果的最大乘积
            int[] dp = new int[n+1];
            dp[2] = 1;
            for(int i = 3; i <= n; i++) {
                for(int j = 1; j <= i-j; j++) {
                    // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，
                    //并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，
                    //j 最大到 i-j,就不会用到 dp[0]与dp[1]
                    dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
                    // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘
                    //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。
                }
            }
            return dp[n];
        }
    }
    ```

    