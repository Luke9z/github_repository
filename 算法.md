# 算法

## KMP

- 模式串和目标串: String str, String model

- 主要要构建最大公共前后缀，这样子匹配的时候，如果发现不同，直接从前一个字符的最大前缀位置开始继续匹配，不需要从头匹配

- ```java
  //构建最大前后公共缀
  public int[] getNext(String model){
      int j = 0;
      int[] next = new int[model.length];
      for(int i = 1; i < model.length(); i++){
          //如果发现不同
          while(j > 0 && model.charAt[i] != model.charAt[j]){
              //从前一个位置的最长前缀开始匹配，因为最长前后缀的长度，所以next[j-1]就是前一个最长前缀后一个位置
              j = next[j];
          }        
          //如果在遍历模式串的时候，前后缀相同，那么j++,表示最长前后缀长度加1
          if(model.charAt[i] == model.charAt[j]){
              j++;
          }
          //给next[i]赋值j，表示这个i位置的最长前后缀为j
          next[i] = j;
      }
  }
  ```

- 构建next数组以后，就可以使用next数组与我们需要匹配的字符串进行匹配了，其原理和我们构建next数组基本相同，在我们进行匹配时，如果发现不同的话，从前一个位置的最长前缀的下一个位置开始匹配。

- ```java
  //返回boolean，是否有这个字符
  public boolean hasThisString(String target, String model){
      int[] next = getNext(model);
      int j = 0;
      
      for(int i = 0; i < target.length(); i++){
          //如果不同，我们需要从不同位置的前一个位置的最长前缀开始，继续匹配
          while(j > 0 && target.charAt(i) != model.charAt(j)){
              j = next[j-1];
          }
          //如果相同，j++
          if(target.charAt(i) == model.charAt(j)){
              //继续匹配下一个
              j++;
          }
          if(j == model.length()){
              //说明全部匹配完成
              return true;
          }
      }
      //说明没有匹配成功
      return false;
  }
  ```
  

## 回溯

### 基础回溯 LeetCode77

- 回溯其实就是树结构，每一层递归中进行for循环

  - ```java
    class Solution {
        List<Integer> combination = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        public List<List<Integer>> combine(int n, int k) {
            countCombine(1, n, k);
            return result;
        }
    
        public void countCombine(int start, int n, int k){
            if (k == 0) {
                result.add(new ArrayList<>(combination));
                return;
            }
            for (int i = start; i <= n + 1 - k; i++) {
                combination.add(i);
                countCombine(i + 1, n, k - 1);
                combination.remove(combination.size() - 1);
            }
        }
    }
    ```


### 回溯去重 LeetCode 40

- 这一题需要将得到的答案去重：

  - Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

    Each number in `candidates` may only be used **once** in the combination.

    **Note:** The solution set must not contain duplicate combinations.

    **Example 1:**

    ```
    Input: candidates = [10,1,2,7,6,1,5], target = 8
    Output: 
    [
    [1,1,6],
    [1,2,5],
    [1,7],
    [2,6]
    ]
    ```

    **Example 2:**

    ```
    Input: candidates = [2,5,2,1,2], target = 5
    Output: 
    [
    [1,2,2],
    [5]
    ]
    ```

- 排序以后，正常使用回溯的话，会有重复的答案，所以我们要在回溯的过程中将重复答案去重，这一步如何达到呢？

  - 注意：以下去重方式只能使用与可以排列的数组，因为排列以后，两个相同的数字会放在一起，这样子才可以用一个used数组来维护，如果数组不允许排列， 那么只能使用set来进行去重

  - 我们可以发现，在同一个组合中，可以出现重复的元素，这是没有问题的，但是不同的组合中，我们不能出现相同的两个组合。

  - 这就需要在for循环的过程中，如果发现前一个元素和当前下标相同，且前一个元素没有在使用中，需要continue跳过了，因为如果前一个元素在选择中的话，说明我们现在在同一个组合中，如果前一个元素没有在选中过程中，说明我们现在在不同的组合，就需要跳过当前元素。

  - 使用一个`int[] used`数组来进行维护，`for循环`主体如下:

  - ```java
    for (int i = startIndex; i < candidates.length && temp + candidates[i] <= target; i++) {
        if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] != 1) {
        	continue;
        }
        temp += candidates[i];
        path.add(candidates[i]);
        used[i] = 1;
        findCombination(i + 1, candidates, target);
        temp -= candidates[i];
        path.remove(path.size() - 1);
        used[i] = 0;
    }
    ```

### 回溯子集问题 LeetCode 78

- 这一题是想找到一个数组的所有子集

  - Given an integer array `nums` of **unique** elements, return *all possible subsets (the power set)*.

    The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

    **Example 1:**

    ```
    Input: nums = [1,2,3]
    Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
    ```

    **Example 2:**

    ```
    Input: nums = [0]
    Output: [[],[0]]
    ```

- 其实这个数组的所有子集，就是我们在回溯过程中，所有的节点。如果回溯作为一个树的话，组合问题就是找到这个树的叶子节点，而子集问题就是找到这个树的所有节点，所以在我们回溯的过程中，将每一个path都收集，就可以获得所有子集了

  - ```java
    public void findSubsets(int startIndex, int[] nums) {
        for (int i = startIndex; i < nums.length; i++) {
            path.add(nums[i]);
            result.add(new ArrayList<>(path));
            findSubsets(i + 1, nums);
            path.remove(path.size() - 1);
        }
    }
    ```

### 回溯子集去重 LeetCode 90

- 其实就是回溯去重与回溯子集相结合，一样建立一个`int[] used`表去进行维护，如果前一个元素正在使用，说明同组，可以重复；前一个元素不在使用，说明不同组，不可以重复使用。

- ```java
  public void findSubsets(int startIndex, int[] nums) {
      for (int i = startIndex; i < nums.length; i++) {
          if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == 0) {
              continue;
          }
              path.add(nums[i]);
              used[i] = 1;
              result.add(new ArrayList<>(path));
              findSubsets(i + 1, nums);
              path.remove(path.size() - 1);
              used[i] = 0;
          }
  }
  ```

### 回溯子集去重，不允许排序 LeetCode 491

- 这道题是不允许对原数组进行排序的，但是去重的原理还是一样的，就是如果单层for循环中使用过了一个元素，这个元素后续就不可以再次使用了，我们利用Set来进行去重

  - Given an integer array `nums`, return *all the different possible non-decreasing subsequences of the given array with at least two elements*. You may return the answer in **any order**.

    **Example 1:**

    ```
    Input: nums = [4,6,7,7]
    Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
    ```

    **Example 2:**

    ```
    Input: nums = [4,4,3,2,1]
    Output: [[4,4]]
    ```

- 主要代码如下：

  - ```java
    public void findAllSubsequences(int startIndex, int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i = startIndex; i < nums.length; i++) {
            //在放入path之前，如果放入的元素比path里面的元素小的话，就跳过这次
            if (!path.isEmpty() && nums[i] < path.get(path.size() - 1)) {
            	continue;
            }
            //如果本层使用过这个元素，那么就跳过
            if (set.contains(nums[i])) {
            	continue;
            }
            path.add(nums[i]);
            set.add(nums[i]);
            if (path.size() >= 2) {
                result.add(new ArrayList<>(path));
            }
            findAllSubsequences(i + 1, nums);
            path.remove(path.size() - 1);
        }
    }
    ```

### 回溯，不需要startIndex，全排列问题，LeetCode 46

- 这道题的话，就不需要使用startIndex来更新每一层的开始下标，因为他要求所有排列的情况，但是我们需要一个`boolean[] used`数组来维护哪些元素我们已经使用过了，这样子就不会重复选择。

  - Given an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.

    **Example 1:**

    ```
    Input: nums = [1,2,3]
    Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    ```

    **Example 2:**

    ```
    Input: nums = [0,1]
    Output: [[0,1],[1,0]]
    ```

    **Example 3:**

    ```
    Input: nums = [1]
    Output: [[1]]
    ```

- 核心代码如下：

  - ```java
    public void findPermutations(int startIndex, int[] nums) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(used[i]){
            	continue;
        	}
            path.add(nums[i]);
            used[i] = true;
            findPermutations(startIndex + 1, nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
    ```

    